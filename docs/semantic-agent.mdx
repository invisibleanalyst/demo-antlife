---
title: "Semantic Agent"
description: "Enhance the PandasAI library with the Semantic Agent for more accurate and interpretable results."
---

## Introduction to the Semantic Agent

The `SemanticAgent` (currently on beta) extends the capabilities of the PandasAI library by adding a semantic layer to its results. Unlike the standard `Agent`, the `SemanticAgent` generates a JSON query, which can then be used to produce Python or SQL code. This approach ensures more accurate and interpretable outputs.

> **Note:** Usage of the Semantic Agent may be subject to a license. For more details, refer to the [license documentation](https://github.com/Sinaptik-AI/pandas-ai/blob/master/pandasai/ee/LICENSE).

## Instantiating the Semantic Agent

Creating an instance of the `SemanticAgent` is similar to creating an instance of an `Agent`.

```python
from pandasai.semantic_agent import SemanticAgent

df = pd.read_csv('revenue.csv')

agent = SemanticAgent(df, config=config)
agent.chat("What are the top 5 revenue streams?")
```

## How the Semantic Agent Works

The Semantic Agent operates in two main steps:

1. Schema generation
2. JSON query generation

### Schema Generation

The first step is schema generation, which structures the data into a schema that the Semantic Agent can use to generate JSON queries. By default, this schema is automatically created, but you can also provide a custom schema if necessary.

#### Automatic Schema Generation

By default, the `SemanticAgent` considers all dataframes passed to it and generates an appropriate schema.

#### Custom Schema

To provide a custom schema, pass a `schema` parameter during the instantiation of the `SemanticAgent`.

```python
salaries_df = pd.DataFrame(
    {
        "EmployeeID": [1, 2, 3, 4, 5],
        "Salary": [5000, 6000, 4500, 7000, 5500],
    }
)

employees_df = pd.DataFrame(
    {
        "EmployeeID": [1, 2, 3, 4, 5],
        "Name": ["John", "Emma", "Liam", "Olivia", "William"],
        "Department": ["HR", "Marketing", "IT", "Marketing", "Finance"],
    }
)

schema = [
    {
        "name": "Employees",
        "table": "Employees",
        "measures": [
            {
                "name": "count",
                "type": "count",
                "sql": "EmployeeID"
            }
        ],
        "dimensions": [
            {
                "name": "EmployeeID",
                "type": "string",
                "sql": "EmployeeID"
            },
            {
                "name": "Department",
                "type": "string",
                "sql": "Department"
            }
        ],
        "joins": [
            {
                "name": "Salaries",
                "join_type":"left",
                "sql": "Employees.EmployeeID = Salaries.EmployeeID"
            }
        ]
    },
    {
        "name": "Salaries",
        "table": "Salaries",
        "measures": [
            {
                "name": "count",
                "type": "count",
                "sql": "EmployeeID"
            },
            {
                "name": "avg_salary",
                "type": "avg",
                "sql": "Salary"
            },
            {
                "name": "max_salary",
                "type": "max",
                "sql": "Salary"
            }
        ],
        "dimensions": [
            {
                "name": "EmployeeID",
                "type": "string",
                "sql": "EmployeeID"
            },
            {
                "name": "Salary",
                "type": "string",
                "sql": "Salary"
            }
        ],
        "joins": [
            {
                "name": "Employees",
                "join_type":"left",
                "sql": "Contracts.contract_code = Fees.contract_id"
            }
        ]
    }
]

agent = SemanticAgent([employees_df, salaries_df], schema=schema)
```

### JSON Query Generation

The second step involves generating a JSON query based on the schema. This query is then used to produce the Python or SQL code required for execution.

#### Example JSON Query

Here's an example of a JSON query generated by the `SemanticAgent`:

```json
{
  "type": "number",
  "dimensions": [],
  "measures": ["Salaries.avg_salary"],
  "timeDimensions": [],
  "filters": [],
  "order": []
}
```

This query is interpreted by the Semantic Agent and converted into executable Python or SQL code.

## Understanding the Query Structure

The JSON query consists of the following fields:

- **type**: Specifies the type of the query (e.g., number, pie, bar, line).
- **dimensions**: Columns used to group the data.
- **measures**: Columns used to calculate data.
- **timeDimensions**: Columns used to group the data by time.
- **filters**: Conditions to filter the data.
- **order**: Columns used to order the data.

This structured approach allows for clear and precise data manipulation, enhancing both accuracy and interpretability.

By leveraging the `SemanticAgent`, users can achieve a deeper understanding and more insightful analysis of their data.
